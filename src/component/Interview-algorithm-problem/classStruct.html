<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 定义一个基类（父类）  
    class Animal {
      constructor(name) {
        this.name = name;
        this.sound = 'unknown';
      }

      speak() {
        console.log(this.name + ' makes a ' + this.sound + ' sound');
      }
    }

    // 定义一个派生类（子类），继承自Animal类  
    class Dog extends Animal {
      constructor(name, breed) {
        // 在子类的构造函数中，必须首先调用super()  
        // 这会调用父类的构造函数，并传递参数（如果有的话）  
        super(name); // 调用父类（Animal）的constructor，传入name  

        // 然后才能为子类添加自己的属性  
        this.breed = breed;

        // 注意：在调用super()之前，不能引用this，因为this是在super()之后被初始化的  
        // 如果尝试在super()之前使用this，会导致运行时错误  

        // 重写父类的speak方法  
        this.speak = function () {
          console.log(this.name + ' (a ' + this.breed + ') barks');
        }
      }
    }

    // 创建一个Dog对象  
    let myDog = new Dog('Buddy', 'Labrador');

    // 调用speak方法  
    myDog.speak(); // 输出: Buddy (a Labrador) barks  

    // 尝试直接访问父类的speak方法（这通常是不推荐的，因为子类可能重写了该方法）  
    // 但为了演示，我们可以使用Object.getPrototypeOf()来获取父类的原型，并调用其方法  
    Object.getPrototypeOf(myDog).speak.call(myDog); // 输出: Buddy makes a unknown sound
  </script>

  <script>
    class foods {
      constructor(name) {
        this.name = name
      }
      select() {
        console.log("i like " + this.name)
      }
    }
    class myRice extends foods {
      constructor(boy, girl) {
        super(name)
        this.boy = boy,
          this.girl = girl
        this.select = () => {
          console.log(this.boy + " like " + this.girl)
        }
      }
    }
    let store = new myRice("zyc", "wbq")
    store.select()
  </script>
</body>

</html>